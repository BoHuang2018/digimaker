// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package entity

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"dm/db"
	"dm/model"
	. "dm/query"
	"dm/type_default/field"
	"github.com/pkg/errors"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Folder is an object representing the database table.
// Implement dm.model.ContentTyper interface
type Folder struct {
	CID        int                 `boil:"id" json:"id" toml:"id" yaml:"id"`
	FolderType string              `boil:"folder_type" json:"folder_type" toml:"folder_type" yaml:"folder_type"`
	Title      field.TextField     `boil:"title" json:"title" toml:"title" yaml:"title"`
	Summary    field.RichTextField `boil:"summary" json:"summary" toml:"summary" yaml:"summary"`
	Published  int                 `boil:"published" json:"published,omitempty" toml:"published" yaml:"published,omitempty"`
	Modified   int                 `boil:"modified" json:"modified,omitempty" toml:"modified" yaml:"modified,omitempty"`
	RemoteID   string              `boil:"remote_id" json:"remote_id" toml:"remote_id" yaml:"remote_id"`

	R        *folderR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L        folderL  `boil:"-" json:"-" toml:"-" yaml:"-"`
	Location `boil:"dm_location,bind"`
}

func (c *Folder) Fields() map[string]model.Fielder {
	return nil
}

func (c *Folder) Values() map[string]interface{} {
	result := make(map[string]interface{})
	result["id"] = c.CID
	result["folder_type"] = c.FolderType
	result["title"] = c.Title
	result["summary"] = c.Summary
	result["published"] = c.Published
	result["modified"] = c.Modified
	result["remote_id"] = c.RemoteID
	return result
}

func (c *Folder) TableName() string {
	return "dm_folder"
}

func (c *Folder) Field(name string) interface{} {
	var result interface{}
	switch name {
	case "id", "CID":
		result = c.CID
	case "folder_type", "FolderType":
		result = c.FolderType
	case "title", "Title":
		result = c.Title
	case "summary", "Summary":
		result = c.Summary
	case "published", "Published":
		result = c.Published
	case "modified", "Modified":
		result = c.Modified
	case "remote_id", "RemoteID":
		result = c.RemoteID
	default:
	}
	return result
}

func (c Folder) Store() error {
	handler := db.DBHanlder()
	if c.CID == 0 {
		id, err := handler.Insert(c.TableName(), c.Values())
		c.CID = id
		if err != nil {
			return err
		}
	} else {
		err := handler.Update(c.TableName(), c.Values(), Cond("id", c.CID))
		return err
	}
	return nil
}

var FolderColumns = struct {
	CID        string
	FolderType string
	Title      string
	Summary    string
	Published  string
	Modified   string
	RemoteID   string
}{
	CID:        "id",
	FolderType: "folder_type",
	Title:      "title",
	Summary:    "summary",
	Published:  "published",
	Modified:   "modified",
	RemoteID:   "remote_id",
}

// FolderRels is where relationship names are stored.
var FolderRels = struct {
}{}

// folderR is where relationships are stored.
type folderR struct {
}

// NewStruct creates a new relationship struct
func (*folderR) NewStruct() *folderR {
	return &folderR{}
}

// folderL is where Load methods for each relationship are stored.
type folderL struct{}

var (
	folderColumns               = []string{"id", "folder_type", "title", "summary", "published", "modified", "remote_id"}
	folderColumnsWithoutDefault = []string{"folder_type", "title", "summary", "published", "modified", "remote_id"}
	folderColumnsWithDefault    = []string{"id"}
	folderPrimaryKeyColumns     = []string{"id"}
)

type (
	// FolderSlice is an alias for a slice of pointers to Folder.
	// This should generally be used opposed to []Folder.
	FolderSlice []*Folder
	// FolderHook is the signature for custom Folder hook methods
	FolderHook func(context.Context, boil.ContextExecutor, *Folder) error

	folderQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	folderType                 = reflect.TypeOf(&Folder{})
	folderMapping              = queries.MakeStructMapping(folderType)
	folderPrimaryKeyMapping, _ = queries.BindMapping(folderType, folderMapping, folderPrimaryKeyColumns)
	folderInsertCacheMut       sync.RWMutex
	folderInsertCache          = make(map[string]insertCache)
	folderUpdateCacheMut       sync.RWMutex
	folderUpdateCache          = make(map[string]updateCache)
	folderUpsertCacheMut       sync.RWMutex
	folderUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var folderBeforeInsertHooks []FolderHook
var folderBeforeUpdateHooks []FolderHook
var folderBeforeDeleteHooks []FolderHook
var folderBeforeUpsertHooks []FolderHook

var folderAfterInsertHooks []FolderHook
var folderAfterSelectHooks []FolderHook
var folderAfterUpdateHooks []FolderHook
var folderAfterDeleteHooks []FolderHook
var folderAfterUpsertHooks []FolderHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Folder) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Folder) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Folder) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Folder) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Folder) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Folder) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Folder) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Folder) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Folder) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range folderAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddFolderHook registers your hook function for all future operations.
func AddFolderHook(hookPoint boil.HookPoint, folderHook FolderHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		folderBeforeInsertHooks = append(folderBeforeInsertHooks, folderHook)
	case boil.BeforeUpdateHook:
		folderBeforeUpdateHooks = append(folderBeforeUpdateHooks, folderHook)
	case boil.BeforeDeleteHook:
		folderBeforeDeleteHooks = append(folderBeforeDeleteHooks, folderHook)
	case boil.BeforeUpsertHook:
		folderBeforeUpsertHooks = append(folderBeforeUpsertHooks, folderHook)
	case boil.AfterInsertHook:
		folderAfterInsertHooks = append(folderAfterInsertHooks, folderHook)
	case boil.AfterSelectHook:
		folderAfterSelectHooks = append(folderAfterSelectHooks, folderHook)
	case boil.AfterUpdateHook:
		folderAfterUpdateHooks = append(folderAfterUpdateHooks, folderHook)
	case boil.AfterDeleteHook:
		folderAfterDeleteHooks = append(folderAfterDeleteHooks, folderHook)
	case boil.AfterUpsertHook:
		folderAfterUpsertHooks = append(folderAfterUpsertHooks, folderHook)
	}
}

// One returns a single folder record from the query.
func (q folderQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Folder, error) {
	o := &Folder{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "entity: failed to execute a one query for dm_folder")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Folder records from the query.
func (q folderQuery) All(ctx context.Context, exec boil.ContextExecutor) (FolderSlice, error) {
	var o []*Folder

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "entity: failed to assign all query results to Folder slice")
	}

	if len(folderAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Folder records in the query.
func (q folderQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "entity: failed to count dm_folder rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q folderQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "entity: failed to check if dm_folder exists")
	}

	return count > 0, nil
}

var mySQLFolderUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Folder) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("entity: no dm_folder provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(folderColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLFolderUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	folderUpsertCacheMut.RLock()
	cache, cached := folderUpsertCache[key]
	folderUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			folderColumns,
			folderColumnsWithDefault,
			folderColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			folderColumns,
			folderPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("entity: unable to upsert dm_folder, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "dm_folder", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `dm_folder` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(folderType, folderMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(folderType, folderMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "entity: unable to upsert for dm_folder")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.CID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == folderMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(folderType, folderMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "entity: unable to retrieve unique values for dm_folder")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "entity: unable to populate default values for dm_folder")
	}

CacheNoHooks:
	if !cached {
		folderUpsertCacheMut.Lock()
		folderUpsertCache[key] = cache
		folderUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}
