
Some principles
----------------

It should NOT block developer to use entry part(in php it's index.php), meaning the developer should be able to embed the system into another system by using api. In general, a developer can extend/customize in different level:
 - invoke the system in go API
 - being invoked in go API(plugin)
 - Template override and extending
 - Config of course
 - Rest api of course

Typical scenario for the developer invoking the system is, eg. if they already has system or other product, and put our system into /site/, they don't need to use rewriterule for this - rewriterule can not do session sharing and api reuse in their system. That might make this system to be more like framework instead of a cms like system.

Query Style
------------
The query should consider below
 - Close to human thinking way. eg. <conent>.List() is better than xxx.Query( "list", <cond> ). It should be a 'layer' independent from sql(not so much independent, but should not show sql thinking from the api).
 - Try to pass less string, but use more pre-built function/const without compromise readability. The benefit are that
  - you have more to check before actually run the query
  - helper when using IDE.
  - more readable
  eg. Query( "id", id ) instead of Query( "id = " + id )
  eg. Query( "id", GT, id ).SortBy( "id", DESC ) Query( new []string{ "filter": "id>"+id, "sort_by": "id desc" } )
 - Try to keep template query(if there is) similar style as go query. If keywords(eg. "sort_by") exists in both, they should be identical.
 - Try to have less way(better only one) for same query, because query api is the product public interface like ui, the best will be one targeting one user group. And it will be well documented and maintained.

**Query styles**
```
//style 1
Content.One( "id", 2121 ).Apply();
Content.List( "id", ">", 2121 ).SortBy( "modified", "desc" ).Apply();
Content.List( "id", GT, 2121 ).SortBy( "modified", DESC ).Apply();

//style 2: query in front instead of end
Content.Query( List( "id", ">", 2121 ).SortBy( "modified", "desc" ) );

//style 3: use string map(json like query).
"id", ">", 2121
Content.Query( new map[string]string{ "id": "212",
                       "modified": ">210",
                       "sort_by": "id desc"} )

```
**AND OR**
```
List( "id", GT, 2121, AND, "author", 1212 )

//more readable, but AND/OR in front?
List( AND( "id", GT, 2121, "author", 1212 ) )

//AND( ...<cond> ) return <cond>
```

**Custom Operators**
Below should work.
```
ids := []int{ 121,23123 }
List( "id", IN, ids )
```


Query extending
--------------
Join should be possible and use same api for extended content should be possible.
