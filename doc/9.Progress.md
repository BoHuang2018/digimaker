
This is a progress notes noting down what's important in different stages, in case of losing concentration or forgetting about things.

Concentration
--------------
Now(phrase1):
 - Model, Database API,
   - common components: log, error type, db interface, config
   - db/SQL & db/RMDB: make query generic for all types
   - api/query style with some working well
   - config with siteaccess(toml or yaml - maybe yaml?)
 - Create content
 - Text & rich text data type
 - Local api
 - Rest Api
 - Permission
 - Example of using

Next:
 - Template with Override rule
 - More operations. eg. copy, move

Next next:
 - Admin ui


Progress Log
---------
**April Week1**
1) db generic query, not use sqlboiler struct query, but use sqlboiler raw since we need all query dynamic
2) Example of db query by fields array
3) Think about query api style
4) Confirm query style, at least for conditions. Create query syntax analyser to build structs

**April Week2**
1) Create rbmb QueryBuilder based on analysed structs
2) Enhance week1's 2) based on 1)
3) Idea of unique id, use it for cluster, also for internal use(internal link typically, where we don't maintain when id is changed because of migration for instance/partition moving/cluster). Plan next: entity update, insert, delete, operation relation between content and location, so we can start content action(draft, publish, edit, delete, move, etc).

[April 13]
- Idea of draft, store with dynamic field( eg. article.SetField( <identifier>, value )). What parameter format can be in api?
  - Way 1: use SetField( <identifier>, value ), in addtional to article.<Attribute> = value
  - Way 2: use marshall for updating/setting attribute?

- Current&next: everything from a request to saving, including
  - simple mvc
  - error handling,
  - dynamic parameter format
  - events before/after action
  - default thing in setting, eg. section, language
  - permission check interface
  - different setting based on site

- Next/next next:
  - field types
  - mechanism of generating & building online
  - rest API about authentication(maybe simple first)
  - template&more query format
  - simple client ui, then(phrase 2):
  - more field types
  - content types(including users)
  - more permission
  - images/files
  - online editor

[April 14]

Is DTO needed? I guess not needed in core, since the field can be changed quite often, you basically have to generate a layer of dto based on definition. In addition, you still need to support DTO visit dynamically. In the end the DTO value is set by a json like format. And we don't use DTO anywhere else. So we can have a "layer of DTO concept based on definition structs and map instances, but no struct generated", where validation will be based on that rule.

[April 15]

putting datatype into entity level might be too low level, it makes it hard to operate(eg. output value when doing sql debug) since it's a struct not basic type like string. It should be a good idea to put most of logic into business logic level.

DataType/FieldType can be in these:
- struct TextField{ viewValue string, storeValue string, definition DataTypeSetting  }
  - convertToView( storedValue string )
  - SetStorageValue( storedValue string ) which invoke converting to view value
  - ViewValue()
  - StorageValue()
There should be an interface for it. eg. FieldType{ ViewValue(), StoredValue() }


One problem becomes, how to easily access value? If it's in database field type, you can get it from entity(eg. <article>.Title will return a TextField Instance), while here it only return a string. Possible way to solve it:

- way1: use one new struct TextFieldStorage which will be used for db. TextFieldStorage has a method called ViewValue() which get view value(which can be struct also)

- way2: Use a converter. eg. convert.ToViewValue( <article>.Title ) will get the view value. In this way the style is function-like instead of OO-like. How is it in template.

The point comes to how to layer this. way1 is more api-nice, but might be against layer(putting too much logic into database level)? way2 has clear separation and might be good for flexiablity(which is a benefit of separated layer)(eg. for extneded normal db field also). But there should be well balanced between these 2.

[April 15 afternoon]

For now we separate in 2 layers:
 - storage entity(eg. TextField) including conversion to view value
 - handler(eg. TextFieldHandler) including conversion to storage value and validation.
The storage is part of storage layer and handler is part of business layer. If there is change on archecture, we may have a dto(view enities) layer for long term. In that case, storage can be pure string, while all the conversion will be on "view entity" level.

[April 17]
Plan for next weeks(eg. 4 weeks)
- handler for create, update, delete
- loader callback mechanism
- queries & template use in query including caches
- permission and apply it to all actions
- rest api(it will be a natural wrap after handlers are done)
- simple editorial ui(will not release, but for demo purpose)

After that
- Generate database, entities based on configuration
- more field types
- admin ui for backend

[April 19]
Something about auto generating:
- It will be hard to add code based on auto generating(better to use partial struct for go?). So the core shouldn't be generated?
- For content types, should it be generated by orm or own generator? benefits to use own generator
   - it can be generated from program using go generate or write to file directly so the setting is totally dynamic(eg. mapping) without generating any middle file
   - more flexiable control(direct mapping on table level)
   - performance better
   - error handle better

[April 20]
Properties in ContentCommon can be in a separate table, or in location if needed.

[April 21]
Next is to finish the ContentHandler.Create() with all dynamic meaning
- Get content type dynamically, which return a ContentTyper
- Dynamically set field eg. content.SetValue( "title", <titleField> ). There may be put in interface ContentTyper.
- So the set value can be set on ContentCommon also since it's a interface and you don't know the ContentCommon

[April 22]
Array of interface is very strange. eg. []Content ,converting instance to it is very difficult, you don't know if you get a value(struct) or a pointer(pointer of the value). If it's from pointer list, it's impossible to convert to this list(you will get a list of pointer which points to the same place).

[April 23]
Content relations, images/videos, attribute relations
- cover images should be saved inside article attribute(either url or image id(use dm_image table for storing all content images(article's cover image, image content, slide shows ). columns can be "id",  "content_type", "url", "uid", "created_time", "modified_time")). There is a centralize place to mangage images attributes - not only image object!
- content relations should use dm_relations table. eg. transations will be using 'transation' relation type
- attribute relation can use content relations(use identifier ), or attribute stored relations(eg. slides:[{id:<location_id1>, name: xxxx},{id:<location_id2>, name:xxxx}]) - not decided yet. On content level it's hard to get list of relations in one attribute.

There is a principle for relations: if it's clear structure(you know where to fetch), it can be done in content level, otherwise store into fields because it will be much better to fetch content list with relation.

How about using both? relations is to keep relations, attribute is to have a "cache" of the relation so it's easier to update. Or use json type in mysql(after version 5.7) or viturl json type(how is the performance?).

[Update]
It might be good to keep both dm_relation and dm_article.relation. The more convenient is use dm_article.relation only for normal relation, to track relation change and more query based on relation, the dm_relation table should be useful(actually mysql json's virtual column can help here in some way. eg. responsible_editor can be a virtual column of relations, and it can support being used as query condition(for reverse query: articles where responsible_editor equals xxxx), the problem is that multiple value responsible_editors is not supported as virtual column ).


[April 24]

The current structure has a presumption that "you know the type before you query", this is fine for direct query, what about indirect query. eg when using relations:
- get an list of article where its related_person is from Norway(article->related_person field->person->country). This is possible since we know it's person.
- What if it's from multi type. eg.

Content model
- 1) [content model]The structure of content table with content_field table may have some benefit, but it will make join with other table very wire. eg. "SELECT * FROM content, content_field, booking WHERE content_field.id = content.id and content_field.identifier ='booking_id'" and booking.id = content_field.value
- 2) [content model] or use content&article_field/folder_field combination, this will make join nicer, but not nice as complete article table. But it will make the common condition query easier(published, modified..). Note: if content is put as common table, it will make it hard to relate to normal table(eg. bookings).
- 3) [content model] put the comment field into location(and rename it to content). In that case, the preassumption becomes "you know the type before you query specific attribute"
- 4) [entities]maybe use a map[<field name>]FieldType so there is no need to generate entities.
- 5) There are 2 types of content: content having location(eg. article, folder) and content having no location(eg. images. They just need parent location they can hook under)
- 6) There are 2 types of relations: relation to location, relation to content.

Now it's "SELECT * FROM content_x booking WHERE content_x.booking_id = booking.id"

Again, the core of content model are locations->contents->relations, contents can be any contents, possibally another new table "eg. order/booking". Relation will play a very important role for extending.

See 0.content-extended-content-relations.png for clarification. Keep 2 things in mind
- Is it needed to abstract content into a separate table(balance easiablity(one table for id name, modified) and extendability( relation can be used for custom contents like booking ) )?
- How to use uid properly. Link? yes. other senario?(relation? no, hard to read id)

[April 25]
There are 2 kinds of relations: attribute level(eg. related links) and content level(eg. translation). It might be more generic that if we have all in attribute level, but just not create cache(eg. called virtual relations). In this case translation is an virtual relation where nor-no is the relatio(n data.

In additional to translation, there are more virtual relation fields, eg. orders: so if there are orders put into relation table. Basically relation table can be treat like normal other relation tables.

Potentially it can be more relation table, based on relation types. But so far it's good for now.

Question: do we need to define this virtual relation field or just leave it in table?
I think it's needed since it define how the relation data is defined and update.

Last: maybe it's better to put relation field into relation table so it's easier to do update. Group_Concat is useful when doing query.

And this relation is mainly for content related, for other case, create own relation table. eg. user's booking better to be in another table, instead of creating a bookings relation field in user. otherwise the table will be very big!
